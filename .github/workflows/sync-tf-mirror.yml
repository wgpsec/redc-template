name: Sync TF Mirror

on:
  schedule:
    - cron: '0 4 * * 0' # æ¯å‘¨æ—¥è¿è¡Œ
  workflow_dispatch:

permissions:
  contents: write

jobs:
  sync-mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Force Sync & Verify
        shell: python
        run: |
          import json
          import urllib.request
          import urllib.error
          import shutil
          import os
          import sys
          import datetime
          import textwrap
          import hashlib
          import base64
          from pathlib import Path
          from concurrent.futures import ThreadPoolExecutor, as_completed

          # ================= é…ç½®åŒºåŸŸ =================
          PROVIDERS = [
              'random', 'null', 'time', 'local', 
              'tls', 'http', 'archive', 'external'
          ]
          
          TARGET_PLATFORMS = [
              ('linux', 'amd64'), ('linux', 'arm64'),
              ('windows', 'amd64'),
              ('darwin', 'amd64'), ('darwin', 'arm64')
          ]
          
          MIRROR_ROOT = Path('public/tf-mirror')
          REGISTRY_API = 'https://registry.terraform.io/v1/providers'
          MIRROR_URL = 'https://redc.wgpsec.org/tf-mirror/'
          MAX_WORKERS = 4
          # ===========================================

          # 1. æš´åŠ›æ¸…ç†æ—§ç›®å½•
          if MIRROR_ROOT.exists():
              print("ğŸ§¹ Cleaning up old mirror directory...")
              shutil.rmtree(MIRROR_ROOT)
          MIRROR_ROOT.mkdir(parents=True, exist_ok=True)

          class MirrorSync:
              def __init__(self, base_dir: Path):
                  self.base_dir = base_dir

              def fetch_text(self, url):
                  req = urllib.request.Request(url, headers={'User-Agent': 'TF-Mirror-Bot'})
                  with urllib.request.urlopen(req, timeout=15) as r:
                      return r.read().decode('utf-8')

              def fetch_json(self, url):
                  content = self.fetch_text(url)
                  return json.loads(content)

              def download_file(self, url, dest_path: Path):
                  if dest_path.exists() and dest_path.stat().st_size > 0:
                      return 'SKIP'
                  try:
                      dest_path.parent.mkdir(parents=True, exist_ok=True)
                      req = urllib.request.Request(url, headers={'User-Agent': 'TF-Mirror-Bot'})
                      with urllib.request.urlopen(req, timeout=60) as r, open(dest_path, 'wb') as f:
                          shutil.copyfileobj(r, f)
                      return 'OK'
                  except Exception as e:
                      if dest_path.exists(): dest_path.unlink()
                      raise e

              def verify_integrity(self, file_path: Path, filename: str, official_sums: str):
                  """
                  è®¡ç®—æœ¬åœ°æ–‡ä»¶çš„ SHA256ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦åœ¨å®˜æ–¹ SHA256SUMS æ–‡ä»¶ä¸­
                  """
                  print(f"   ğŸ›¡ï¸  Verifying integrity for {filename}...")
                  sha256_hash = hashlib.sha256()
                  with open(file_path, "rb") as f:
                      for byte_block in iter(lambda: f.read(4096), b""):
                          sha256_hash.update(byte_block)
                  
                  # 1. è·å– Hex æ ¼å¼ Hash (ç”¨äºæ¯”å¯¹)
                  local_hex = sha256_hash.hexdigest()
                  
                  # 2. æ„é€ å®˜æ–¹æ ¡éªŒè¡Œç‰¹å¾ (æ ¼å¼: hash  filename)
                  expected_entry = f"{local_hex}  {filename}"
                  
                  if expected_entry not in official_sums:
                      print(f"   âŒ Hash Mismatch! Local: {local_hex}")
                      return None # æ ¡éªŒå¤±è´¥
                  
                  # 3. ç”Ÿæˆ Terraform éœ€è¦çš„ h1:Base64 æ ¼å¼
                  digest = sha256_hash.digest()
                  b64_hash = base64.b64encode(digest).decode('utf-8')
                  return f"h1:{b64_hash}"

              def process_single_arch(self, namespace, type_name, version, os_name, arch, provider_dir, official_sums):
                  try:
                      dl_api = f'{REGISTRY_API}/{namespace}/{type_name}/{version}/download/{os_name}/{arch}'
                      dl_info = self.fetch_json(dl_api)
                      filename = dl_info['filename']
                      file_url = dl_info['download_url']
                      
                      dest = provider_dir / filename
                      
                      # 1. ä¸‹è½½
                      self.download_file(file_url, dest)
                      
                      # 2. æ ¡éªŒ (å¯¹æ¯”å®˜æ–¹æŒ‡çº¹)
                      tf_hash = self.verify_integrity(dest, filename, official_sums)
                      
                      if not tf_hash:
                          # æ ¡éªŒå¤±è´¥ï¼Œåˆ é™¤æ–‡ä»¶ï¼ŒæŠ›å‡ºå¼‚å¸¸
                          if dest.exists(): dest.unlink()
                          return {"status": "failed", "error": "Checksum verification failed"}

                      return {
                          "status": "success",
                          "os": os_name,
                          "arch": arch,
                          "filename": filename,
                          "hash": tf_hash
                      }
                  except urllib.error.HTTPError:
                      return {"status": "skipped"}
                  except Exception as e:
                      return {"status": "failed", "error": str(e)}

              def process_provider(self, full_name):
                  if '/' in full_name:
                      namespace, type_name = full_name.split('/')
                  else:
                      namespace = 'hashicorp'
                      type_name = full_name

                  print(f'ğŸ” Analyzing {namespace}/{type_name}...')
                  
                  try:
                      # 1. è·å–ç‰ˆæœ¬ä¿¡æ¯
                      meta_url = f'{REGISTRY_API}/{namespace}/{type_name}'
                      meta = self.fetch_json(meta_url)
                      version = meta['version']
                      
                      # 2. è·å–è¯¥ç‰ˆæœ¬çš„è¯¦ç»†å…ƒæ•°æ® (ä¸ºäº†æ‹¿åˆ° shasums_url)
                      version_meta_url = f'{REGISTRY_API}/{namespace}/{type_name}/{version}'
                      version_meta = self.fetch_json(version_meta_url)
                      shasums_url = version_meta.get('shasums_url')
                      shasums_sig_url = version_meta.get('shasums_signature_url')

                      if not shasums_url:
                          print(f"   âš ï¸ No SHA256SUMS url found for {type_name}, skipping verification.")
                          return {'status': 'failed', 'name': type_name}

                      # 3. ä¸‹è½½å®˜æ–¹ SHA256SUMS å†…å®¹ (ç”¨äºå†…å­˜æ ¡éªŒ)
                      print(f"   â¬‡ï¸  Fetching official SHA256SUMS for v{version}...")
                      official_sums_content = self.fetch_text(shasums_url)

                      provider_dir = self.base_dir / 'registry.terraform.io' / namespace / type_name
                      provider_dir.mkdir(parents=True, exist_ok=True)
                      
                      archives_data = {}
                      
                      # 4. å¹¶å‘ä¸‹è½½å¹¶æ ¡éªŒ
                      with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
                          futures = []
                          for os_name, arch in TARGET_PLATFORMS:
                              futures.append(executor.submit(
                                  self.process_single_arch, 
                                  namespace, type_name, version, os_name, arch, provider_dir, official_sums_content
                              ))
                          
                          for future in as_completed(futures):
                              res = future.result()
                              if res["status"] == "success":
                                  key = f"{res['os']}_{res['arch']}"
                                  print(f"   âœ… Verified: {res['filename']}")
                                  archives_data[key] = {
                                      "url": res['filename'],
                                      "hashes": [res['hash']]
                                  }
                              elif res["status"] == "failed":
                                  print(f"   âŒ Failed: {res.get('error')}")

                      # 5. ç”Ÿæˆ JSON æ–‡ä»¶
                      if archives_data:
                          index_data = {"versions": {version: {}}}
                          with open(provider_dir / 'index.json', 'w') as f:
                              json.dump(index_data, f, indent=2)

                          version_file_data = {"archives": archives_data}
                          with open(provider_dir / f'{version}.json', 'w') as f:
                              json.dump(version_file_data, f, indent=2)
                          
                          return {'name': type_name, 'namespace': namespace, 'version': version, 'status': 'success'}
                      else:
                           return {'name': type_name, 'namespace': namespace, 'version': version, 'status': 'empty'}

                  except Exception as e:
                      print(f'ğŸš« Error: {namespace}/{type_name} - {e}')
                      return {'name': type_name, 'namespace': namespace, 'version': 'Error', 'status': 'failed'}

          # --- Main ---
          syncer = MirrorSync(MIRROR_ROOT)
          results = []
          
          with ThreadPoolExecutor(max_workers=3) as main_executor:
              futures = {main_executor.submit(syncer.process_provider, p): p for p in PROVIDERS}
              for f in as_completed(futures):
                  res = f.result()
                  results.append(res)
                  print(f"ğŸ‰ Completed {res['namespace']}/{res['name']}")

          # --- Generate HTML ---
          print('ğŸ“ Generating index.html...')
          timestamp = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
          
          config_lines = []
          for r in sorted(results, key=lambda x: x['name']):
              if r['status'] == 'success':
                   config_lines.append(f'"registry.terraform.io/{r["namespace"]}/{r["name"]}"')
          config_str = ",\n    ".join(config_lines)
          
          cards_html = ""
          for r in sorted(results, key=lambda x: x['name']):
              if r['status'] == 'success':
                  cards_html += f"""
                  <div class="card">
                      <div class="name">{r['namespace']}/{r['name']}</div>
                      <div class="ver">v{r['version']}</div>
                  </div>
                  """

          html_template = textwrap.dedent("""
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Terraform Provider Mirror</title>
              <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 2rem; color: #333; line-height: 1.6; }
                  h1 { border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
                  .status { background: #f6f8fa; padding: 1rem; border-radius: 6px; margin-bottom: 2rem; border: 1px solid #e1e4e8; }
                  code { background: #eee; padding: 0.2rem 0.4rem; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
                  pre { background: #2d333b; color: #adbac7; padding: 1.5rem; border-radius: 6px; overflow-x: auto; font-family: monospace; }
                  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem; }
                  .card { border: 1px solid #e1e4e8; border-radius: 6px; padding: 1rem; transition: transform 0.2s; }
                  .card:hover { transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
                  .name { font-weight: bold; color: #0366d6; margin-bottom: 0.5rem; }
                  .ver { font-size: 0.85em; color: #586069; background: #f1f8ff; display: inline-block; padding: 2px 8px; border-radius: 12px; }
                  footer { margin-top: 3rem; text-align: center; color: #666; font-size: 0.85rem; border-top: 1px solid #eee; padding-top: 1rem; }
              </style>
          </head>
          <body>
              <h1>Terraform Provider Mirror</h1>
              <div class="status">
                  <p><strong>Protocol:</strong> Network Mirror (Integrity Verified)</p>
                  <p><strong>Last Updated:</strong> {{TIMESTAMP}}</p>
              </div>

              <h2>Usage Configuration</h2>
              <p>Add the following to your <code>~/.terraformrc</code>:</p>
              <pre>
          provider_installation {
            network_mirror {
              url = "{{MIRROR_URL}}"
              include = [
                {{CONFIG_STR}}
              ]
            }
            direct {
              exclude = [
                {{CONFIG_STR}}
              ]
            }
          }</pre>

              <h2>Synced Providers ({{COUNT}})</h2>
              <div class="grid">
                  {{CARDS_HTML}}
              </div>
          </body>
          </html>
          """)
          
          final_html = html_template.replace("{{TIMESTAMP}}", timestamp) \
                                    .replace("{{MIRROR_URL}}", MIRROR_URL) \
                                    .replace("{{CONFIG_STR}}", config_str) \
                                    .replace("{{COUNT}}", str(len(results))) \
                                    .replace("{{CARDS_HTML}}", cards_html)
          
          with open(MIRROR_ROOT / 'index.html', 'w', encoding='utf-8') as f:
              f.write(final_html)
          print('âœ… index.html created successfully.')

      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          publish_branch: gh-pages
          keep_files: true
          commit_message: "Mirror: Sync with Official Integrity Verification"
